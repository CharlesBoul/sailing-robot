#!/usr/bin/python
#
# Node publishes current waypoint
# passes on to next waypoint when within given range

import rospy
from std_msgs.msg import Float32
from sensor_msgs.msg import NavSatFix

wp_table = rospy.get_param("/wp/table")
wp_list = rospy.get_param("/wp/list")

class WaypointState(object):
    def __init__(self):
        self.acceptRadius = rospy.get_param("/wp/acceptRadius")
        self.distance = self.acceptRadius * 2.  # initialise assuming we start away from wp
    def get_distance(self, msg):
        self.distance = msg.data

def wp_publisher():
    msg = NavSatFix()
    wp_index = 0
    rate = rospy.Rate(rospy.get_param("/config/rate"))

    while not rospy.is_shutdown():
        if wp_index < len(wp_list):
            current_wp = wp_list[wp_index]
            msg.latitude = wp_table[current_wp][0]
            msg.longitude = wp_table[current_wp][1]
            if state.distance > state.acceptRadius:
                wp_pub.publish(msg)
                rate.sleep()
            else:
                # wp has been reached
                rospy.loginfo("waypoint " + current_wp + " has been reached")
                wp_index += 1
                state.distance = state.acceptRadius * 2. # reset assuming we are outside the accept radius of the next wp
                if wp_index == len(wp_list):
                    rospy.logwarn("List of waypoints finished")


if __name__ == '__main__':
    try:
        wp_pub = rospy.Publisher('/next_wp', NavSatFix, queue_size=10)
        state = WaypointState()
        rospy.init_node("publish_waypoint_from_list", anonymous=True)
        rospy.Subscriber('/distance_to_waypoint', Float32, state.get_distance)
        wp_publisher()
    except rospy.ROSInterruptException:
        pass
