#!/usr/bin/env python
#
# Node receives current waypoint from path planner
# calculates goal heading for reaching the waypoint as fast as possible

import rospy
from std_msgs.msg import Float32
from std_msgs.msg import Float64
from std_msgs.msg import String

from LatLon import LatLon
import sailing_robot
from sailing_robot.heading_planning import HeadingPlan
from sailing_robot.navigation import Navigation
from sensor_msgs.msg import NavSatFix


def goal_heading_publisher(heading_data):
    pub = rospy.Publisher("/goal_heading", Float32, queue_size=10)
    pub_state = rospy.Publisher("/sailing_state", String, queue_size=10)
    distance_to_wp = rospy.Publisher("/distance_to_waypoint", Float32, queue_size=10)
    heading_to_wp = rospy.Publisher("/heading_to_waypoint", Float32, queue_size=10)
    rate = rospy.Rate(rospy.get_param("/config/rate"))

    while not rospy.is_shutdown():
        state, goal_heading = heading_data.calculate_state_and_goal()
        pub.publish(goal_heading)
        pub_state.publish(state)

        d, h = heading_data.distance_heading_to_waypoint()
        distance_to_wp.publish(d)
        heading_to_wp.publish(h)

        rate.sleep()


if __name__ == '__main__':
    try:
        rospy.init_node("publish_goal_heading", anonymous=True)
        nav_params = rospy.get_param("/navigation")
        tackline_dist = nav_params['tackline_distance'] / 1000 # m to km
        beating_angle = nav_params['deadzone']
        nav = Navigation(beating_angle=beating_angle, utm_zone = nav_params['utm_zone'])
        nav.subscribe_topics()
        
        target = rospy.get_param('dummy')
        waypoint = LatLon(target['latitude'], target['longitude'])
        
        heading_data = HeadingPlan(nav=nav, waypoint=waypoint, tack_line_offset=tackline_dist)
        goal_heading_publisher(heading_data)
    except rospy.ROSInterruptException:
        pass
