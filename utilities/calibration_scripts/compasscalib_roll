#!/usr/bin/python

#This Python 2 program reads the data from an LSM303D and an L3GD20H which are both attached to the I2C bus of a Raspberry Pi.
#Both can be purchased as a unit from Pololu as their MinIMU-9 v3 Gyro, Accelerometer, and Compass  product.
#
#First follow the procedure to enable I2C on R-Pi.
#1. Add the lines "ic2-bcm2708" and "i2c-dev" to the file /etc/modules
#2. Comment out the line "blacklist ic2-bcm2708" (with a #) in the file /etc/modprobe.d/raspi-blacklist.conf
#3. Install I2C utility (including smbus) with the command "apt-get install python-smbus i2c-tools"
#4. Connect the I2C device to the SDA and SCL pins of the Raspberry Pi and detect it using the command "i2cdetect -y 1".  It should show up as 1D (typically) or 1E (if the jumper is set).
from __future__ import print_function

import csv
import numpy as np
import os.path
from scipy.optimize import leastsq
import sys
import time, math
import rospy

my_dir = os.path.dirname(__file__)
robot_src_dir = os.path.abspath(os.path.join(my_dir, '../../src/sailing_robot/src'))
sys.path.append(robot_src_dir)

from sailing_robot.imu_utils import ImuReader

IMU_BUS = 1
LGD = 0x6b #Device I2C slave address
LSM = 0x1d #Device I2C slave address

imu = ImuReader(IMU_BUS, LSM, LGD)
imu.check_connected()
imu.configure_for_reading()

def pitch_and_roll():
    AccX, AccY, AccZ = imu.read_acceleration()
    pitch = math.atan2(AccX, math.sqrt(AccX**2 + AccZ**2))
    roll = math.atan2(-AccY, -AccZ)
    return math.degrees(pitch), math.degrees(roll)

data_X = []
data_Y = []

print('Hold the boat level and gently turn it around several times')
raw_input('Press enter to start')

f = open('calibration_level.csv', 'w')
cw = csv.writer(f)
cw.writerow(['mag_x', 'mag_y', 'mag_z', 'acc_x', 'acc_y', 'acc_z'])

for i in range(300):
    try:
        #Read data from the chips ----------------------
        time.sleep(0.1)
        
        magx, magy, magz = imu.read_mag_field()
        accx, accy, accz = imu.read_acceleration()
        cw.writerow([magx, magy, magz, accx, accy, accz])

        data_X.append(magx)
        data_Y.append(magy)

        minx = min(data_X)
        miny = min(data_Y)
        maxx = max(data_X)
        maxy = max(data_Y)
        
        print
        print('min x', minx)
        print('max x', maxx)
        print('min y', miny)
        print('max y', maxy)
        
    except KeyboardInterrupt:
        print("Interrupted")
        break

f.close()

minx = min(data_X)
miny = min(data_Y)

maxx = max(data_X)
maxy = max(data_Y)

offset_X = (maxx + minx)/2
offset_Y = (maxy + miny)/2

range_X = maxx - minx
range_Y = maxy - miny

print('Now hold the boat at a steady heading and roll it side to side.')
raw_input('Press enter when ready')

pitches = []
rolls = []
mag_x = []
mag_y = []
mag_z = []

f = open('calibration_roll.csv', 'w')
cw = csv.writer(f)
cw.writerow(['mag_x', 'mag_y', 'mag_z', 'acc_x', 'acc_y', 'acc_z'])


for i in range(300):
    try:
        time.sleep(0.1)
        AccX, AccY, AccZ = imu.read_acceleration()
        pitch_r = math.atan2(AccX, math.sqrt(AccX**2 + AccZ**2))
        roll_r = math.atan2(-AccY, -AccZ)
        pitch, roll = math.degrees(pitch_r), math.degrees(roll_r)
        # pitch, roll = pitch_and_roll()
        mag_xyz = imu.read_mag_field()
        cw.writerow(list(mag_xyz) + [AccX, AccY, AccZ])
        
        pitches.append(pitch)
        rolls.append(roll)
        mag_x.append(mag_xyz[0])
        mag_y.append(mag_xyz[1])
        mag_z.append(mag_xyz[2])
        
        print('     / min / current / max')
        print('pitch : {:>5.1f} {:>5.1f} {:>5.1f}'.format(min(pitches), pitch, max(pitches)))
        print('roll  : {:>5.1f} {:>5.1f} {:>5.1f}'.format(min(rolls), roll, max(rolls)))
    except KeyboardInterrupt:
        print('Interrupted')
        break

f.close()

adjusted_x = (np.array(mag_x) - offset_X) / range_X
adjusted_y = (np.array(mag_y) - offset_Y) / range_Y
raw_z = np.array(mag_z)

roll_d = np.array(rolls)
roll_r = np.radians(roll_d)
pitch_r = np.radians(pitches)

# Take our correct y field as the points where we're within 3 degrees of level.
y_flat = adjusted_y[(-3 < roll_d) & (roll_d < +3)].mean()

def mag_y_comp_residuals(p):
    MagY_comp = (adjusted_x * np.sin(roll_r) * np.sin(pitch_r)) +\
     (adjusted_y * np.cos(roll_r)) - (((raw_z - p[0]) / p[1])* np.sin(roll_r) * np.cos(pitch_r)) 
    return MagY_comp - y_flat

res, ier = leastsq(mag_y_comp_residuals, (1, 1))
# According to the docs, an integer code between 1 and 4 (inclusive) indicates
# success.
assert 1 <= ier <= 4

offset_Z, range_Z = res
offset_Z = offset_Z.item()
range_Z = range_Z.item()

rospy.set_param('/calibration/compass', {'XOFFSET': offset_X,
                                          'YOFFSET': offset_Y,
                                          'ZOFFSET': offset_Z,
                                          'XSCALE': range_X,
                                          'YSCALE': range_Y,
                                          'ZSCALE': range_Z,
                                          })


print("XOFFSET = " + str(offset_X))
print("YOFFSET = " + str(offset_Y))
print("ZOFFSET = " + str(offset_Z))
print("XSCALE = " + str(range_X))
print("YSCALE = " + str(range_Y))
print("ZSCALE = " + str(range_Z))
